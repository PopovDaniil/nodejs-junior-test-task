# 1. Что будет выведено на консоль при выполнении следующего скрипта:

```js
console.log(1)
Promise
    .resolve()
    .then(() => console.log(2))
    .then(() => {
        setTimeout(() => {
            console.log(3)
        }, 0)
    })
    .then(() => console.log(4));
console.log(5)
```

По возможности объясните почему не `12345`, уточните как работает асинхронность в JS при условии, что он однопоточный (можно очень кратко, главное суть :))

## Ответ
В консоль выведется: 15243
Это связано как раз с тем, что JavaScript однопоточный и не может выполнять несколько инструкций параллельно. Поэтому, приведённый выше код начнёт исполняться со своего первого уровня, где находятся 3 инструкции:
- `console.log(1)`
- `Promise.resolve().then()...`
- `console.log(5)`

После их выполнения в консоли окажется `15`, а остальные команды (на втором уровене), определённые в методах `then()` как обработчики, будут помещены в очередь на выполнение после инструкции `console.log(5)`. 

Уже после их выполнения в консоли будет `1524`, и в очередь будет поставлена последняя инструкция (третий уровень) `console.log(3)`, переданная как обработчик в `setTimeout()`. И, так как нулевая задержка невозможна, тройка появится в консоли с небольшой задержкой, около 5 мс

# 2. Функция-парсер.

Пример из практики. Есть CLI (command line interface, програмка, которая используется в консоли (терминале)). Необходимо написать парсер, который на вход получает help message CLI'ки, а на выход отдает массив команд этой CLI'ки.

На вход функции парсера будет приходить следующая строчка:

```bash
{cliName} <command>

Create template

Commands:
  {cliName} {command1}  {description1}
  {cliName} {command2}  {description2}

Options:
  -h, --help     Show help  [boolean]
  -V, --version  Show version number  [boolean]
  -v, --verbose  Verbose output information  [boolean] [default: false]
```

На выходе нужно получить вот такой массив:

```js
[
  '{cliName} {command1} --help',
  '{cliName} {command2} --help'
]
```

PS: вместо `{cliName}`, `{command1}`, `{command2}`, `{description1}` и `{description2}` будут реальные названия + команд м.б. больше чем две. Считайте, что название CLI'ки и названия команд не содержат пробелов. Ниже конкретный пример:

```bash
template-creator <command>

Create template

Commands:
  template-creator microservice  Create microservice template
  template-creator dictionary  Create dictionary template
  template-creator model  Create model template

Options:
  -h, --help     Show help  [boolean]
  -V, --version  Show version number  [boolean]
  -v, --verbose  Verbose output information  [boolean] [default: false]
```
## Решение
```js
const getCommands = help => {
    const cliName = help.match(/(.*)\s<command>/)[1]
    const comReg = new RegExp(`${cliName}\\s(.*?)\\s`, 'g')
    const commands = help.match(comReg)
      .slice(1)
      .map(
        str => str.concat('--help')
      )
    return commands
}
```

# 3. Code review

## Задача:

Нужно по переданным в параметрах идентификаторам авторов получить информацию по этим авторам + книги этих авторов с рейтингом выше заданной величины (рейтинг - это также параметр функции).

## Контекст:

Программист выполнял задачу согласно описанным выше требованиям. Закончил и прислал Вам merge request, который нужно проверить.

## Что нужно сделать:

Нужно проверить merge request. Опишите, что Вы измените. Можете предоставить свой вариант функции. В рамках этой программы можно менять все, лишь бы проект стал лучше. Не нужно писать новые функции или писать новый функционал существующих, главное изменить именну эту, при этом у Вас есть возможность исправить названия и входные данные существующих, а также code style программы в целом.

```js
function authors(uaerId, rating) {
    let result = [];
    // получаем пользователей по айди 
    await getusers({id: uaerId});
    // получаем книги с рейтингом выше заданного значения
    let books = await getBooks(rating);
    // выбираем все книги по присланному пользователю
    for (let i = 0; i < books.length; i++) {
        const book = books[i];
        if (book.userId === uaerId) {
            result[userId] = book.nazvanie;
        }
    }
    // фильтруем результаты, чтобы получить массив без пустых значений 
    result = result.filter((item) => item);

    return result;
}
```
## Исправленная функция
```js
// Опечатка в имени параметра - изменено на userId
// В задаче сказано "по идентификаторам авторов", т.е. userId правильнее назвать userIds, и он будет массивом id пользователей
// Функцию лучше назвать так, чтобы по названию было понятно её назначение - хотя бы getAuthorsBooks
function getAuthorsBooks(userIds, rating) {
  // получаем пользователей по айди 
    // Имя переменной не описывает то, что в ней хранится - изменено на authors
    // Плохая практика: функция видимо изменяет переменную (если не изменяет, то её вызов вообще не нужен), определённую выше неё - лучше чтобы она просто возвращала результат и он присваивался в переменную, но придётся изменить getusers
    // Имя функции лучше написать в camelCase - getUsers
    // Если переменная не будет изменяться далее, лучше её объявить как const
    // Выбрать пользователей по нескольким id можно через map
    const authors = userIds.map(async userId => await getUsers({id: userId}));
    // получаем книги с рейтингом выше заданного значения
    // Было бы логичнее, и код стал бы гибче, если бы функция getBooks, как и getUsers, принимала объект и искала книги, соответствующие его полям, в данном случае по rating (getBooks тоже придётся изменить)
    // Если переменная не будет изменяться далее, лучше её объявить как const
    const books = await getBooks({ rating });
    // выбираем все книги по присланному пользователю
    // Лучше объявить новый массив, который будет содержать авторов с заданными id, а в поле books каждого автора записать массив его книг
    const authorsBooks = authors.map(author => ({
      ...author,
      books: books.filter(book => book.userId === author.userId)
    }))
    //Итог: прежняя функция возвращала массив строк с названиями книг, новая же возвращает массив полноценных объектов-пользователей у каждого из которых в поле books хранится список написанных им книг. Если же понадобится получать только массив названий книг, то можно написать простую функцию-обёртку.
    return authorsBooks;
}
```


# 4. В чем отличие LEFT JOIN от INNER JOIN

В базе данных имеются две таблички (книги и авторы). В каждой табличке по 5 записей.

Таблица `users`:

| userId | name    |
| ------ | ------- |
| 1      | Иван    |
| 2      | Игнат   |
| 3      | Игорь   |
| 4      | Ибрагим |
| 5      | Илья    |

Таблица `books`:

| bookId | title  | userId |
| ------ | ------ | ------ |
| 1      | Книга1 | 1      |
| 2      | Книга2 | 1      |
| 3      | Книга3 | 2      |
| 4      | Книга4 | 2      |
| 5      | Книга5 | 3      |

Что вернет каждый из запросов?

-
  ```sql
  SELECT u.name, b.title
  FROM  users as u
  LEFT JOIN books as b
  ON u.userId = b.userId
  ```

  Результат запроса:

  | name  | title |
  | :---: | :---: |
  |   ?   |   ?   |
  |   ?   |   ?   |
  |   ?   |   ?   |
-
  ```sql
  SELECT u.name, b.title
  FROM  users as u
  INNER JOIN books as b
  ON u.userId = b.userId
  ```

  Результат запроса:

  | name  | title |
  | :---: | :---: |
  |   ?   |   ?   |
  |   ?   |   ?   |
  |   ?   |   ?   |

# 5. Что такое транзакция

Что такое транзакция, зачем она нужна? Лучше отвечать своими словами и придумать простенький пример где это особенно нужно.

Транзакция - это несколько операций(запросов) к базе данных, соединённых в один большой запрос. Транзакция проходит успешно, если ни один из запросов в её составе не вызвал ошибки. 

Если же возникла ошибка в одном из запросов, то транзакция прерывается, и все соверешённые до ошибки действия в ней откатываются назад. При этом, даже успешно завершённую транзакцию можно откатить.

Ещё одно свойство транзакции - она гарантирует, что в процессе её выполнения никто не изменит данные, с которыми она работает, т.е. она их блокирует

### Пример
Пользователь делает 2 запроса: на выборку и на удаление одной и той же записи. Если их не объединить в одну транзакцию, то какой-нибудь другой пользователь может успеть изменить или удалить эту же запись после выборки первым пользователем, но перед удалением.

Тогда результат будет непредсказуем, хотя ошибку БД скорее всего не выдаст: просто первый пользователь получит сообщение, что удалено 0 строк
Транзакция же заблокирует доступ к этой записи на время, пока с ней работает первый пользователь и для него результат будет предсказуем